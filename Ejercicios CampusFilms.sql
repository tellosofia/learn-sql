-- 1- Devuelve todas las películas
SELECT 
	*
FROM
	MOVIES;

-- 2- Devuelve todos los géneros existentes
SELECT 
	*
FROM	
	GENRES;

-- 3- Devuelve la lista de todos los estudios de grabación que estén activos
SELECT 	
	STUDIO_NAME AS ACTIVE_STUDIOS
FROM
	STUDIOS
WHERE 
	STUDIO_ACTIVE = 1; -- o con TRUE porque el tipo de dato es BIT

-- 4- Devuelve una lista de los 20 últimos miembros en anotarse a la plataforma
SELECT
	USER_NAME 
FROM
	USERS
ORDER BY 
	USER_JOIN_DATE DESC
LIMIT 
	20;

-- 5- Devuelve las 20 duraciones de películas más frecuentes, ordenados de mayor a menor
SELECT
	MOVIE_DURATION,
	COUNT(MOVIE_ID) AS DURATION_COUNT -- mejor siempre contar con un ID o algo así que *
FROM
	MOVIES
GROUP BY 
	MOVIE_DURATION
ORDER BY
	DURATION_COUNT DESC
LIMIT
	20;

-- 6- Devuelve las películas del año 2000 en adelante que empiecen por la letra A.
SELECT
	*
FROM
	MOVIES
WHERE
	MOVIE_RELEASE_DATE >= '2000-01-01' -- o YEAR (DATE) >= 2000 O con DATE en cada uno(sqlite) 
	AND
	MOVIE_NAME LIKE 'A%';

-- 7- Devuelve los actores nacidos un mes de Junio
SELECT
	ACTOR_NAME,
	ACTOR_BIRTH_DATE 
FROM
	ACTORS
WHERE
	EXTRACT(MONTH FROM ACTOR_BIRTH_DATE) = 6; -- o solo MONTH(ACTOR_BIRTH_DATE)

-- 8- Devuelve los actores nacidos cualquier mes que no sea Junio y que sigan vivos
SELECT
	ACTOR_NAME,
	ACTOR_BIRTH_DATE 
FROM
	ACTORS
WHERE
	EXTRACT(MONTH FROM ACTOR_BIRTH_DATE) <> 6 -- o MONTH(ACTOR_BIRTH_DATE) != 6
	AND
	ACTOR_DEAD_DATE IS NULL;

-- 9- Devuelve el nombre y la edad de todos los directores menores o iguales de 50 años que estén vivos
SELECT
	DIRECTOR_NAME AS DIRECTOR,
	YEAR(NOW) - YEAR(DIRECTOR_BIRTH_DATE) AS AGE
FROM
	DIRECTORS
WHERE
	(YEAR(NOW) - YEAR(DIRECTOR_BIRTH_DATE)) <= 50
	AND
	DIRECTOR_DEAD_DATE IS NULL
ORDER BY
	AGE;

-- otra manera
SELECT
	DIRECTOR_NAME AS DIRECTOR,
	DATEDIFF(YEAR, DIRECTOR_BIRTH_DATE, TODAY()) AS AGE
FROM
	DIRECTORS
WHERE
	DATEDIFF(YEAR, DIRECTOR_BIRTH_DATE, TODAY()) <= 50
	AND
	DIRECTOR_DEAD_DATE IS NULL
ORDER BY
	AGE;

-- 10- Devuelve el nombre y la edad de todos los actores menores de 50 años que hayan fallecido
SELECT
	ACTOR_NAME,
	YEAR(ACTOR_DEAD_DATE) - YEAR(ACTOR_BIRTH_DATE) AS AGE 
FROM
	ACTORS
WHERE 	
	(YEAR(ACTOR_DEAD_DATE) - YEAR(ACTOR_BIRTH_DATE)) <= 50
	AND
	ACTOR_DEAD_DATE IS NOT NULL;

--con datediff
SELECT
	ACTOR_NAME,
	DATEDIFF(YEAR, ACTOR_BIRTH_DATE, ACTOR_DEAD_DATE) AS AGE 
FROM
	ACTORS
WHERE 	
	DATEDIFF(YEAR, ACTOR_BIRTH_DATE, ACTOR_DEAD_DATE) <= 50
	AND
	ACTOR_DEAD_DATE IS NOT NULL;

-- 11 - Devuelve el nombre de todos los directores menores o iguales de 40 años que estén vivos
SELECT
	DIRECTOR_NAME
FROM
	DIRECTORS
WHERE
	(YEAR(NOW) - YEAR(DIRECTOR_BIRTH_DATE)) <= 40;

-- DATEDIFF
SELECT
	DIRECTOR_NAME,
	DIRECTOR_BIRTH_DATE 
FROM
	DIRECTORS
WHERE
	DIRECTOR_DEAD_DATE IS NULL 
	AND
	DATEDIFF(YEAR, DIRECTOR_BIRTH_DATE, TODAY()) <= 40;

-- 12- Indica la edad media de los directores vivos
SELECT 
	AVG(YEAR(NOW) - YEAR(DIRECTOR_BIRTH_DATE)) -- IGUAL USAR DATEDIFF
FROM
	DIRECTORS
WHERE
	DIRECTOR_DEAD_DATE IS NULL;

-- 13- Indica la edad media de los actores que han fallecido
SELECT 
	AVG(YEAR(ACTOR_DEAD_DATE) - YEAR(ACTOR_BIRTH_DATE))
FROM
	ACTORS
WHERE 
	ACTOR_DEAD_DATE IS NOT NULL;

-- DATEDIFF - ES MÁS CORRECTO USAR DATEDIFF PARA QUE COJA TODO ADECUADAMENTE EN EL CÁLCULO
SELECT 
	AVG(DATEDIFF(YEAR, ACTOR_BIRTH_DATE, ACTOR_DEAD_DATE))
FROM
	ACTORS
WHERE 
	ACTOR_DEAD_DATE IS NOT NULL;

-- 14- Devuelve el nombre de todas las películas y el nombre del estudio que las ha realizado
SELECT
	m.MOVIE_NAME,
	s.STUDIO_NAME
FROM
	MOVIES m
INNER JOIN 
	STUDIOS s 
	ON 
		m.STUDIO_ID = s.STUDIO_ID
ORDER BY
	s.STUDIO_NAME,
	m.MOVIE_NAME;
	
-- 15- Devuelve los miembros que accedieron al menos una película entre el año 2010 y el 2015
SELECT
	DISTINCT (u.USER_NAME) 
FROM
	USERS u 
INNER JOIN
	USER_MOVIE_ACCESS uma 
	ON
		u.USER_ID = uma.USER_ID
WHERE
	uma.ACCESS_DATE BETWEEN '2010-01-01' AND '2015-12-31'; 

-- con YEAR
SELECT
	DISTINCT (u.USER_NAME)
FROM
	USERS u 
INNER JOIN
	USER_MOVIE_ACCESS uma 
	ON
		u.USER_ID = uma.USER_ID
WHERE
	YEAR(uma.ACCESS_DATE) >= 2010
	AND
	YEAR(uma.ACCESS_DATE) <= 2015;

SELECT * FROM USER_MOVIE_ACCESS uma;

-- 16- Devuelve cuantas películas hay de cada país
SELECT 
	n.NATIONALITY_NAME AS COUNTRY,
	COUNT(m.MOVIE_NAME) AS MOVIES_PER_COUNTRY
FROM 	
	MOVIES m
INNER JOIN
	NATIONALITIES n
	ON
		m.NATIONALITY_ID = n.NATIONALITY_ID
GROUP BY
	COUNTRY
ORDER BY
	MOVIES_PER_COUNTRY DESC;
	
-- 17- Devuelve todas las películas que hay de género documental
SELECT 
	m.*
FROM 
	MOVIES m
WHERE
	m.GENRE_ID = 2; -- mejor usar 'Documentary' por si el genre cambiara o usar una subconsulta

-- CON JOIN
SELECT 
	m.MOVIE_NAME,
	g.GENRE_NAME 
FROM 
	MOVIES m
INNER JOIN 
	GENRES g 
	ON
	m.GENRE_ID = g.GENRE_ID 
WHERE
	g.GENRE_NAME LIKE 'Documentary';

-- con Subquery
SELECT 
	m.*
FROM 
	MOVIES m
WHERE
	m.GENRE_ID = (SELECT GENRE_ID FROM GENRES WHERE GENRE_NAME LIKE 'Documentary');
	
-- 18- Devuelve todas las películas creadas por directores nacidos a partir de 1980 y que todavía están vivos
SELECT
	m.*
FROM
	MOVIES m 
INNER JOIN
	DIRECTORS d
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID
WHERE
	d.DIRECTOR_BIRTH_DATE >= '1980-01-01' -- si hacemos de esta manera puede hacer inconsistencias en la fecha
	AND
	d.DIRECTOR_DEAD_DATE IS NULL;

-- mejor acostumbrarnos a usar DATE etc., funciones que extraigan la info entera, además es más eficiente
-- que extraer la info de una cadena de texto
SELECT
	m.*
FROM
	MOVIES m 
INNER JOIN
	DIRECTORS d
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID
WHERE
	YEAR(d.DIRECTOR_BIRTH_DATE) >= 1980 
	AND
	d.DIRECTOR_DEAD_DATE IS NULL;

-- con subquery ¿?

/* 19- Indica si hay alguna coincidencia de nacimiento de ciudad (y si las hay, indicarlas) entre los miembros de la plataforma y 
 los directores */
SELECT 
	u.USER_TOWN,
	d.DIRECTOR_BIRTH_PLACE 
FROM
	USERS u
INNER JOIN
	DIRECTORS d
	ON 	
		u.USER_TOWN = d.DIRECTOR_BIRTH_PLACE; -- SQL es case sensitive
		
-- podría usarse el upper/lower pero en esta bbdd no es necesario

-- 20- Devuelve el nombre y el año de todas las películas que han sido producidas por un estudio que actualmente no esté activo
SELECT
	m.MOVIE_NAME,
	YEAR(m.MOVIE_RELEASE_DATE) AS "YEAR"
FROM
	MOVIES m
INNER JOIN
	STUDIOS s
	ON
		m.STUDIO_ID = s.STUDIO_ID
WHERE
	s.STUDIO_ACTIVE = 0 -- o FALSE
ORDER BY
	"YEAR";

-- 21- Devuelve una lista de las últimas 10 películas a las que se ha accedido
SELECT 
	m.MOVIE_NAME,
	uma.ACCESS_DATE 
FROM
	MOVIES m
INNER JOIN
	USER_MOVIE_ACCESS uma 
	ON
		m.MOVIE_ID = uma.MOVIE_ID
ORDER BY 
	uma.ACCESS_DATE DESC
LIMIT
	10;

-- 22- Indica cuántas películas ha realizado cada director antes de cumplir 41 años
SELECT
	d.DIRECTOR_NAME AS DIRECTOR,
	COUNT(m.MOVIE_ID) AS MOVIES_MADE
FROM
	MOVIES m 
INNER JOIN
	DIRECTORS d 
	ON
	m.DIRECTOR_ID = d.DIRECTOR_ID
WHERE
	DATEDIFF(YEAR, d.DIRECTOR_BIRTH_DATE, m.MOVIE_RELEASE_DATE) < 41
GROUP BY
	DIRECTOR
ORDER BY
	MOVIES_MADE DESC;

SELECT * FROM DIRECTORS d; 

-- 23- Indica cuál es la media de duración de las películas de cada director
SELECT
	d.DIRECTOR_NAME AS DIRECTOR,
	ROUND(AVG(m.MOVIE_DURATION), 0) AS AVG_DURATION
FROM
	MOVIES m 
INNER JOIN
	DIRECTORS d 
	ON
	m.DIRECTOR_ID = d.DIRECTOR_ID
GROUP BY
	DIRECTOR
ORDER BY
	AVG_DURATION;

/* 24- Indica cuál es la el nombre y la duración mínima de las películas a las que se ha accedido en los últimos 2 años por los 
miembros del plataforma (La “fecha de ejecución” de esta consulta es el 25-01-2019) */
SELECT
	m.MOVIE_NAME,
	MIN(m.MOVIE_DURATION) AS DURATION
FROM
	MOVIES m 
INNER JOIN
	USER_MOVIE_ACCESS uma
	ON
		m.MOVIE_ID = uma.MOVIE_ID 
WHERE
	ACCESS_DATE >= DATEADD(YEAR, -2, DATE '2019-01-25') 
GROUP BY
	m.MOVIE_NAME
ORDER BY
	DURATION
LIMIT 1;

-- Solución Pablo	
SELECT GROUP_CONCAT(M.MOVIE_NAME) AS MOVIE_NAME,
       M.MOVIE_DURATION
FROM USER_MOVIE_ACCESS UMA
INNER JOIN MOVIES M ON UMA.MOVIE_ID = M.MOVIE_ID
WHERE DATEADD(YEAR, -2, DATE '2019-01-25') < UMA.ACCESS_DATE
GROUP BY M.MOVIE_DURATION
ORDER BY M.MOVIE_DURATION ASC
LIMIT 1; 

-- SELECT * FROM USER_MOVIE_ACCESS uma ORDER BY ACCESS_DATE DESC;

/* 25- Indica el número de películas que hayan hecho los directores durante las décadas de los 60, 70 y 80 que contengan la palabra 
 “The” en cualquier parte del título */
SELECT 
	d.DIRECTOR_NAME AS DIRECTOR,
	COUNT(m.MOVIE_ID) AS "60s_70s_80s_MOVIES"
FROM
	MOVIES m
INNER JOIN
	DIRECTORS d 
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID 
WHERE
	LOWER(m.MOVIE_NAME) LIKE '%the%'
	AND
	m.MOVIE_RELEASE_DATE BETWEEN '1960-01-01' AND '1989-12-31'
GROUP BY
	DIRECTOR;

-- 26- Lista nombre, nacionalidad y director de todas las películas
SELECT 
	m.MOVIE_NAME AS MOVIE,
	n.NATIONALITY_NAME AS NATIONALITY,
	d.DIRECTOR_NAME AS DIRECTOR
FROM
	MOVIES m
INNER JOIN
	DIRECTORS d 
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID
INNER JOIN
	NATIONALITIES n 
	ON 
	m.NATIONALITY_ID = n.NATIONALITY_ID
ORDER BY 
	NATIONALITY,
	DIRECTOR;

-- 27- Muestra las películas con los actores que han participado en cada una de ellas
SELECT
	m.MOVIE_NAME AS MOVIE,
	a.ACTOR_NAME AS "ACTORS"
FROM
	MOVIES m 
INNER JOIN
	MOVIES_ACTORS ma 
	ON
		m.MOVIE_ID = ma.MOVIE_ID
INNER JOIN 
	ACTORS a 
	ON
		ma.ACTOR_ID = a.ACTOR_ID
ORDER BY
	MOVIE,
	"ACTORS";

-- 28- Indica cual es el nombre del director del que más películas se ha accedido
SELECT
	d.DIRECTOR_NAME AS DIRECTOR,
	COUNT(uma.ACCESS_DATE) AS "ACCESS_#"
FROM
	DIRECTORS d 
INNER JOIN
	MOVIES m 
	ON
		d.DIRECTOR_ID = m.DIRECTOR_ID
INNER JOIN
	USER_MOVIE_ACCESS uma 
	ON
		m.MOVIE_ID = uma.MOVIE_ID
GROUP BY 
	DIRECTOR
ORDER BY 
	"ACCESS_#" DESC
LIMIT
	1;

-- 29- Indica cuantos premios han ganado cada uno de los estudios con las películas que han creado
SELECT 
	s.STUDIO_NAME AS STUDIO,
	m.MOVIE_NAME AS MOVIE,
	SUM(a.AWARD_WIN) AS AWARDS_PER_MOVIE
FROM
	STUDIOS s
INNER JOIN
	MOVIES m 
	ON
		s.STUDIO_ID = m.STUDIO_ID
INNER JOIN
	AWARDS a 
	ON
		m.MOVIE_ID = a.MOVIE_ID
GROUP BY
	STUDIO,
	MOVIE
ORDER BY 
	STUDIO,
	AWARDS_PER_MOVIE ,
	MOVIE;

SELECT 
	s.STUDIO_NAME AS STUDIO,
	SUM(a.AWARD_WIN) AS TOTAL_AWARDS
FROM
	STUDIOS s
INNER JOIN
	MOVIES m 
	ON
		s.STUDIO_ID = m.STUDIO_ID
INNER JOIN
	AWARDS a 
	ON
		m.MOVIE_ID = a.MOVIE_ID
GROUP BY
	STUDIO
ORDER BY 
	TOTAL_AWARDS DESC;

/* 30- Indica el número de premios a los que estuvo nominado un actor, pero que no ha conseguido (Si una película está nominada 
a un premio, su actor también lo está) */
SELECT
	a2.ACTOR_NAME AS ACTOR,
	m.MOVIE_NAME AS MOVIE,
	SUM(a.AWARD_ALMOST_WIN) AS NOT_WON_NOMINATION
FROM
	AWARDS a 
INNER JOIN
	MOVIES m 
	ON
		a.MOVIE_ID = m.MOVIE_ID
INNER JOIN
	MOVIES_ACTORS ma 
	ON
		m.MOVIE_ID = ma.MOVIE_ID 
INNER JOIN
	ACTORS a2 
	ON
		ma.ACTOR_ID = a2.ACTOR_ID
GROUP BY
	ACTOR,
	MOVIE
ORDER BY 
	ACTOR,
	NOT_WON_NOMINATION;

SELECT
	a2.ACTOR_NAME AS ACTOR,
	SUM(a.AWARD_ALMOST_WIN) AS NOT_WON_NOMINATION
FROM
	AWARDS a 
INNER JOIN
	MOVIES m 
	ON
		a.MOVIE_ID = m.MOVIE_ID
INNER JOIN
	MOVIES_ACTORS ma 
	ON
		m.MOVIE_ID = ma.MOVIE_ID 
INNER JOIN
	ACTORS a2 
	ON
		ma.ACTOR_ID = a2.ACTOR_ID
GROUP BY
	ACTOR
ORDER BY 
	NOT_WON_NOMINATION;

-- 31- Indica cuantos actores y directores hicieron películas para los estudios no activos
SELECT 
	s.STUDIO_NAME AS STUDIO,
	COUNT(DISTINCT a.ACTOR_NAME) AS ACTOR_COUNT,
	COUNT(DISTINCT d.DIRECTOR_NAME) AS DIRECTOR_COUNT
FROM
	STUDIOS s
INNER JOIN
	MOVIES m 
	ON
		s.STUDIO_ID = m.STUDIO_ID
INNER JOIN
	DIRECTORS d 
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID
INNER JOIN
	MOVIES_ACTORS ma 
	ON
		m.MOVIE_ID = ma.MOVIE_ID
INNER JOIN
	ACTORS a 
	ON
		ma.ACTOR_ID = a.ACTOR_ID
WHERE
	s.STUDIO_ACTIVE = 0
GROUP BY
	STUDIO; -- en esta consulta sale un conteo diferente porque se duplican actores/directores en combinación con el estudio

-- consulta correcta
SELECT COUNT(DISTINCT M.DIRECTOR_ID) AS DIRECTOR_NUMBER,
       COUNT(DISTINCT MA.ACTOR_ID) AS ACTOR_NUMBER
FROM STUDIOS S
INNER JOIN MOVIES M ON M.STUDIO_ID = S.STUDIO_ID
INNER JOIN MOVIES_ACTORS MA ON MA.MOVIE_ID = M.MOVIE_ID
WHERE S.STUDIO_ACTIVE = FALSE;

/* 32- Indica el nombre, ciudad, y teléfono de todos los miembros de la plataforma que hayan accedido películas que hayan sido 
nominadas a más de 150 premios y ganaran menos de 50 */
SELECT 
	DISTINCT u.USER_NAME AS USER,
	u.USER_TOWN AS CITY,
	u.USER_PHONE AS PHONE
FROM 
	USERS u 
INNER JOIN
	USER_MOVIE_ACCESS uma 
	ON
		u.USER_ID = uma.USER_ID
INNER JOIN
	MOVIES m 
	ON 
		uma.MOVIE_ID = m.MOVIE_ID 
INNER JOIN
	AWARDS a 
	ON
		m.MOVIE_ID = a.MOVIE_ID
WHERE
	a.AWARD_NOMINATION > 150
	AND
	a.AWARD_WIN < 50;

-- con Subquery
SELECT DISTINCT U.USER_NAME,
                U.USER_TOWN,
                U.USER_PHONE
FROM USER_MOVIE_ACCESS UMA
INNER JOIN USERS U ON UMA.USER_ID = U.USER_ID
WHERE UMA.MOVIE_ID IN
    (SELECT MOVIE_ID
     FROM AWARDS
     WHERE AWARD_NOMINATION > 150
       AND AWARD_WIN < 50);

/* 33- Comprueba si hay errores en la BD entre las películas y directores (un director muerto en el 76 no puede dirigir una película 
en el 88)*/
SELECT
	*
FROM
	MOVIES m 
INNER JOIN
	DIRECTORS d
	ON
		m.DIRECTOR_ID = d.DIRECTOR_ID
WHERE 
	m.MOVIE_RELEASE_DATE > d.DIRECTOR_DEAD_DATE;
 
/* 34- Utilizando la información de la sentencia anterior, modifica la fecha de defunción a un año más tarde del estreno de la película 
(mediante sentencia SQL)*/

-- se puede hacer mediante un UPDATE o una cosa específica de hsqldb que es MERGE INTO

-- UPDATE DIRECTORS SET DIRECTOR_DEAD_DATE ... WHERE DIRECTOR_ID = 27 
-- UPDATE DIRECTORS SET DIRECTOR_DEAD_DATE = '2010-04-08' WHERE DIRECTOR_ID = 47;

/* opción correcta: no "manual" sino haciendo subqueries en el SET y WHERE */

UPDATE
	DIRECTORS
SET
	DIRECTOR_DEAD_DATE = (
	SELECT
		DATE_ADD(MAX(m.MOVIE_RELEASE_DATE), INTERVAL '1' YEAR)
	FROM
			MOVIES m
	INNER JOIN
			DIRECTORS d
			ON
				m.DIRECTOR_ID = d.DIRECTOR_ID
	WHERE 
			d.DIRECTOR_DEAD_DATE  IS NOT NULL 
		AND
			m.MOVIE_RELEASE_DATE > d.DIRECTOR_DEAD_DATE
		AND
			m.DIRECTOR_ID = d.DIRECTOR_ID 
	GROUP BY
		d.DIRECTOR_ID 
			)
WHERE
	DIRECTOR_ID IN (
	SELECT
			DISTINCT m.DIRECTOR_ID
	FROM
			MOVIES m
	INNER JOIN
			DIRECTORS d
			ON
				m.DIRECTOR_ID = d.DIRECTOR_ID
	WHERE
			d.DIRECTOR_DEAD_DATE  IS NOT NULL 
		AND
			m.MOVIE_RELEASE_DATE > d.DIRECTOR_DEAD_DATE);
		-- AND
			-- m.DIRECTOR_ID = d.DIRECTOR_ID); -- esto sobraba

-- Solución de Pablo

UPDATE DIRECTORS
SET DIRECTOR_DEAD_DATE =
  (SELECT MAX(DATEADD(YEAR, 1, M.MOVIE_RELEASE_DATE)) AS DIRECTOR_DEAD_DATE
   FROM MOVIES M
   INNER JOIN DIRECTORS D ON M.DIRECTOR_ID = D.DIRECTOR_ID
   WHERE D.DIRECTOR_DEAD_DATE IS NOT NULL
     AND D.DIRECTOR_DEAD_DATE < M.MOVIE_RELEASE_DATE
     AND D.DIRECTOR_ID = DIRECTORS.DIRECTOR_ID
   GROUP BY DIRECTOR_NAME,
            DIRECTOR_DEAD_DATE)
WHERE DIRECTOR_ID IN
    (SELECT DISTINCT D.DIRECTOR_ID
     FROM MOVIES M
     INNER JOIN DIRECTORS D ON M.DIRECTOR_ID = D.DIRECTOR_ID
     WHERE D.DIRECTOR_DEAD_DATE IS NOT NULL
       AND D.DIRECTOR_DEAD_DATE < M.MOVIE_RELEASE_DATE);

-- 35- Indica cuál es el género favorito de cada uno de los directores cuando dirigen una película
WITH G_COUNT AS(
		SELECT
			d.DIRECTOR_NAME AS DIRECTOR,
			g.GENRE_NAME AS GENRE,
			COUNT(g.GENRE_NAME) AS GENRE_COUNT
		FROM
			MOVIES m
		INNER JOIN
			GENRES g
			ON
				m.GENRE_ID = g.GENRE_ID 
		INNER JOIN 
			DIRECTORS d 
			ON
				m.DIRECTOR_ID = d.DIRECTOR_ID
		GROUP BY
			DIRECTOR,
			GENRE
),
MAX_GEN AS (
SELECT
		DIRECTOR,
		MAX(GENRE_COUNT) AS MAX_COUNT
FROM
		G_COUNT
GROUP BY
		DIRECTOR 
)
SELECT
	gen.DIRECTOR,
	gen.GENRE AS FAV_GENRE, -- group_concat + group by 
	gen.GENRE_COUNT
FROM
	G_COUNT gen
INNER JOIN
	MAX_GEN mx
	ON
		gen.DIRECTOR = mx.DIRECTOR
	AND
		gen.GENRE_COUNT = mx.MAX_COUNT 
ORDER BY
	gen.DIRECTOR,
	gen.GENRE_COUNT;

-- con GROUP_CONCAT
WITH G_COUNT AS(
		SELECT
			d.DIRECTOR_NAME AS DIRECTOR,
			g.GENRE_NAME AS GENRE,
			COUNT(g.GENRE_NAME) AS GENRE_COUNT
		FROM
			MOVIES m
		INNER JOIN
			GENRES g
			ON
				m.GENRE_ID = g.GENRE_ID 
		INNER JOIN 
			DIRECTORS d 
			ON
				m.DIRECTOR_ID = d.DIRECTOR_ID
		GROUP BY
			DIRECTOR,
			GENRE
),
MAX_GEN AS (
SELECT
		DIRECTOR,
		MAX(GENRE_COUNT) AS MAX_COUNT
FROM
		G_COUNT
GROUP BY
		DIRECTOR 
)
SELECT
	gen.DIRECTOR,
	GROUP_CONCAT(gen.GENRE) AS FAV_GENRE 
FROM
	G_COUNT gen
INNER JOIN
	MAX_GEN mx
	ON
		gen.DIRECTOR = mx.DIRECTOR
	AND
		gen.GENRE_COUNT = mx.MAX_COUNT 
GROUP BY
	gen.DIRECTOR 
ORDER BY
	gen.DIRECTOR;
	
-- punto de partida
SELECT 
	DIRECTOR,
	MAX(GENRE_COUNT)
FROM (
		SELECT
			d.DIRECTOR_NAME AS DIRECTOR,
			g.GENRE_NAME AS GENRE,
			COUNT(g.GENRE_NAME) AS GENRE_COUNT
		FROM
			MOVIES m
		INNER JOIN
			GENRES g
			ON
				m.GENRE_ID = g.GENRE_ID 
		INNER JOIN 
			DIRECTORS d 
			ON
				m.DIRECTOR_ID = d.DIRECTOR_ID
		GROUP BY
			DIRECTOR,
			GENRE)
GROUP BY
	DIRECTOR
ORDER BY 
	MAX(GENRE_COUNT) DESC;

-- Solución Pablo
WITH GENRE_COUNTS AS
  (SELECT D.DIRECTOR_ID,
          D.DIRECTOR_NAME,
          G.GENRE_ID,
          G.GENRE_NAME,
          COUNT(*) AS NUM_MOVIES
   FROM MOVIES M
   INNER JOIN GENRES G ON M.GENRE_ID = G.GENRE_ID
   INNER JOIN DIRECTORS D ON M.DIRECTOR_ID = D.DIRECTOR_ID
   GROUP BY D.DIRECTOR_ID,
            D.DIRECTOR_NAME,
            G.GENRE_ID,
            G.GENRE_NAME),
     MAX_GENRE AS
  (SELECT DIRECTOR_ID,
          MAX(NUM_MOVIES) AS MAX_MOVIES
   FROM GENRE_COUNTS
   GROUP BY DIRECTOR_ID)
SELECT GC.DIRECTOR_NAME,
       GROUP_CONCAT(GC.GENRE_NAME) AS GENRE_NAME
FROM GENRE_COUNTS GC
INNER JOIN MAX_GENRE MG ON GC.DIRECTOR_ID = MG.DIRECTOR_ID
AND GC.NUM_MOVIES = MG.MAX_MOVIES
GROUP BY GC.DIRECTOR_NAME;

-- 36- Indica cuál es la nacionalidad favorita de cada uno de los estudios en la producción de las películas
-- consulta inicial
SELECT
	s.STUDIO_NAME AS STUDIO,
	n.NATIONALITY_NAME AS COUNTRY,
	COUNT(m.MOVIE_NAME) AS COUNTRY_COUNT
FROM
	NATIONALITIES n 
INNER JOIN
	MOVIES m 
	ON
		n.NATIONALITY_ID = m.NATIONALITY_ID
INNER JOIN 
	STUDIOS s 
	ON
		m.STUDIO_ID = s.STUDIO_ID
GROUP BY
	STUDIO,
	COUNTRY;

-- solución sin GROUP_CONCAT
WITH COUNTS AS (
		SELECT
		s.STUDIO_NAME AS STUDIO,
		n.NATIONALITY_NAME AS COUNTRY,
		COUNT(m.MOVIE_NAME) AS COUNTRY_COUNT
		FROM
			NATIONALITIES n 
		INNER JOIN
			MOVIES m 
			ON
				n.NATIONALITY_ID = m.NATIONALITY_ID
		INNER JOIN 
			STUDIOS s 
			ON
				m.STUDIO_ID = s.STUDIO_ID
		GROUP BY
			STUDIO,
			COUNTRY
),
MAX_COUNT AS (
		SELECT
			STUDIO,
			MAX(COUNTRY_COUNT) AS TOP_COUNTRY
		FROM
			COUNTS 
		GROUP BY
			STUDIO
)
SELECT 
	c.STUDIO,
	c.COUNTRY,
	mx.TOP_COUNTRY 
FROM 
	COUNTS c
INNER JOIN
	MAX_COUNT mx
	ON
		c.STUDIO = mx.STUDIO 
		AND
		c.COUNTRY_COUNT = mx.TOP_COUNTRY
ORDER BY
	c.STUDIO,
	mx.TOP_COUNTRY DESC;

-- CON GROUP_CONCAT
WITH COUNTS AS (
		SELECT
		s.STUDIO_NAME AS STUDIO,
		n.NATIONALITY_NAME AS COUNTRY,
		COUNT(m.MOVIE_NAME) AS COUNTRY_COUNT
		FROM
			NATIONALITIES n 
		INNER JOIN
			MOVIES m 
			ON
				n.NATIONALITY_ID = m.NATIONALITY_ID
		INNER JOIN 
			STUDIOS s 
			ON
				m.STUDIO_ID = s.STUDIO_ID
		GROUP BY
			STUDIO,
			COUNTRY
),
MAX_COUNT AS (
		SELECT
			STUDIO,
			MAX(COUNTRY_COUNT) AS TOP_COUNTRY
		FROM
			COUNTS 
		GROUP BY
			STUDIO
)
SELECT 
	c.STUDIO,
	GROUP_CONCAT(c.COUNTRY) AS FAV_COUNTRIES 
FROM 
	COUNTS c
INNER JOIN
	MAX_COUNT mx
	ON
		c.STUDIO = mx.STUDIO 
		AND
		c.COUNTRY_COUNT = mx.TOP_COUNTRY
GROUP BY
	c.STUDIO 
ORDER BY
	c.STUDIO;

-- Soluciones Pablo
SELECT STUDIO_NAME,
       GROUP_CONCAT(NATIONALITY_NAME) AS NATIONALITY_NAME
FROM
  (SELECT COUNT(N.NATIONALITY_ID) AS NUM_MOVIES,
          S.STUDIO_NAME,
          N.NATIONALITY_NAME,
          S.STUDIO_ID,
          N.NATIONALITY_ID
   FROM MOVIES M
   INNER JOIN NATIONALITIES N ON N.NATIONALITY_ID = M.NATIONALITY_ID
   INNER JOIN STUDIOS S ON S.STUDIO_ID = M.STUDIO_ID
   GROUP BY S.STUDIO_ID,
            N.NATIONALITY_ID
   ORDER BY S.STUDIO_ID ASC,
            NUM_MOVIES DESC) TOT
INNER JOIN
  (SELECT STUDIO_ID,
          MAX (NUM_MOVIES) AS NUM_MOVIES
   FROM
     (SELECT COUNT(N.NATIONALITY_ID) AS NUM_MOVIES,
             S.STUDIO_NAME,
             N.NATIONALITY_NAME,
             S.STUDIO_ID,
             N.NATIONALITY_ID
      FROM MOVIES M
      INNER JOIN NATIONALITIES N ON N.NATIONALITY_ID = M.NATIONALITY_ID
      INNER JOIN STUDIOS S ON S.STUDIO_ID = M.STUDIO_ID
      GROUP BY S.STUDIO_ID,
               N.NATIONALITY_ID
      ORDER BY S.STUDIO_ID ASC,
               NUM_MOVIES DESC)
   GROUP BY STUDIO_ID) MAX ON TOT.STUDIO_ID = MAX.STUDIO_ID
AND TOT.NUM_MOVIES = MAX.NUM_MOVIES
GROUP BY STUDIO_NAME;

WITH TOTAL_NAT AS
  (SELECT COUNT(N.NATIONALITY_ID) AS NUM_MOVIES,
          S.STUDIO_NAME,
          N.NATIONALITY_NAME,
          S.STUDIO_ID,
          N.NATIONALITY_ID
   FROM MOVIES M
   INNER JOIN NATIONALITIES N ON N.NATIONALITY_ID = M.NATIONALITY_ID
   INNER JOIN STUDIOS S ON S.STUDIO_ID = M.STUDIO_ID
   GROUP BY S.STUDIO_ID,
            N.NATIONALITY_ID
   ORDER BY S.STUDIO_ID ASC,
            NUM_MOVIES DESC),
     MAX_NAT AS
  (SELECT STUDIO_ID,
          MAX(NUM_MOVIES) AS MAX_MOVIES
   FROM TOTAL_NAT
   GROUP BY STUDIO_ID)
SELECT STUDIO_NAME,
       GROUP_CONCAT(NATIONALITY_NAME) AS NATIONALITY_NAME
FROM TOTAL_NAT AS TN
INNER JOIN MAX_NAT MN ON TN.STUDIO_ID = MN.STUDIO_ID
AND TN.NUM_MOVIES = MN.MAX_MOVIES
GROUP BY STUDIO_NAME;

/* 37- Indica cuál fue la primera película a la que accedieron los miembros de la plataforma cuyos teléfonos tengan como último 
dígito el ID de alguna nacionalidad*/

-- Solución inicial
WITH MEMBER_MOVIE AS (
		SELECT
			m.MOVIE_NAME AS MOVIE,
			u.USER_NAME AS MEMBER,
			u.USER_PHONE AS PHONE,
			u.USER_ID,
			uma.ACCESS_DATE 
		FROM
			MOVIES m 
		INNER JOIN
			USER_MOVIE_ACCESS uma 
			ON
				m.MOVIE_ID = uma.MOVIE_ID
		INNER JOIN
			USERS u
			ON
				uma.USER_ID = u.USER_ID
		WHERE
			CAST(RIGHT(u.USER_PHONE, 1) AS INT) IN (SELECT NATIONALITY_ID FROM NATIONALITIES)
),
FIRST_ACCESS AS (	
		SELECT USER_ID, MIN(ACCESS_DATE) AS FIRST_DATE FROM USER_MOVIE_ACCESS GROUP BY USER_ID
)
SELECT
	mm.MOVIE,
	mm.MEMBER,
	mm.PHONE,
	f.FIRST_DATE 
FROM
	MEMBER_MOVIE mm
INNER JOIN
	FIRST_ACCESS f
	ON
		mm.USER_ID = f.USER_ID 
		AND
		mm.ACCESS_DATE = f.FIRST_DATE
ORDER BY
	f.FIRST_DATE;

-- Solución Pablo
WITH PHONE_DIGIT AS
  (SELECT USER_NAME,
          USER_ID,
          SUBSTR(USER_PHONE, LENGTH(USER_PHONE), 1) AS LAST_NUMBER
   FROM USERS),
     USER_NAT AS
  (SELECT N.NATIONALITY_ID,
          M.USER_NAME,
          M.USER_ID
   FROM NATIONALITIES N
   INNER JOIN PHONE_DIGIT M ON N.NATIONALITY_ID = M.LAST_NUMBER),
     MOVIE_ACCESS AS
  (SELECT UN.NATIONALITY_ID,
          UN.USER_NAME,
          UMA.USER_ID,
          UMA.MOVIE_ID,
          UMA.ACCESS_DATE
   FROM USER_NAT UN
   INNER JOIN USER_MOVIE_ACCESS UMA ON UN.USER_ID = UMA.USER_ID),
     MIN_ACCESS AS
  (SELECT USER_ID,
          MIN(ACCESS_DATE) AS ACCESS_DATE
   FROM MOVIE_ACCESS
   GROUP BY USER_ID)
SELECT MOA.USER_NAME,
       M.MOVIE_NAME
FROM MOVIE_ACCESS MOA
INNER JOIN MIN_ACCESS MIA ON MOA.ACCESS_DATE = MIA.ACCESS_DATE
AND MOA.USER_ID = MIA.USER_ID
INNER JOIN MOVIES M ON MOA.MOVIE_ID = M.MOVIE_ID;
		
	
	